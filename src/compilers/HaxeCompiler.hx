// Copyright (c) 2025 AndrÃ©s E. G.
//
// This software is licensed under the MIT License.
// See the LICENSE file for more details.


package src.compilers;

import src.utils.LibsManager;
import sys.io.File;
import sys.FileSystem;
import src.JsonFile;
import src.SlushiUtils;
import src.Main;
import src.utils.Defines;

/**
 * The Haxe compiler, a class that handles the compilation of Haxe projects using
 * the Haxe compiler iself and a HXML file (https://haxe.org/manual/compiler-usage-hxml.html).
 * 
 * Author: Slushi.
 */

class HaxeCompiler {
	static var jsonFile:JsonStruct = JsonFile.getJson();
	static var exitCodeNum:Int = 0;

	static final hxmlFileName:String = "haxeHXML";

	public static var forceDebugMode:Bool = false;

	public static function init():Void {
		if (jsonFile == null) {
			SlushiUtils.printMsg("Error loading [haxeNXConfig.json]", ERROR);
			return;
		}

		// Check if all required fields are set
		if (jsonFile.haxeConfig.sourceDir == "") {
			SlushiUtils.printMsg("sourceDir in [haxeNXConfig.json -> haxeConfig.sourceDir] is empty", ERROR);
			exitCodeNum = 3;
			return;
		} else if (jsonFile.haxeConfig.hxMain == "") {
			SlushiUtils.printMsg("hxMain in [haxeNXConfig.json -> haxeConfig.hxMain] is empty", ERROR);
			exitCodeNum = 3;
			return;
		} else if (jsonFile.haxeConfig.cppOutDir == "") {
			SlushiUtils.printMsg("cppOutDir in [haxeNXConfig.json -> haxeConfig.cppOutDir] is empty", ERROR);
			exitCodeNum = 3;
			return;
		}

		var reportStyle:String = jsonFile.haxeConfig.errorReportingStyle;
		var validStyles = ["classic", "indent", "pretty"];
		var style = jsonFile.haxeConfig.errorReportingStyle;
		if (style == "" || !Lambda.has(validStyles, style)) {
			SlushiUtils.printMsg("errorReportingStyle in [haxeNXConfig.json -> haxeConfig.errorReportingStyle] is invalid ("
				+ style
				+ "), using [classic]", WARN);
			reportStyle = "classic";
		} else {
			reportStyle = style;
		}

		SlushiUtils.printMsg("Trying to compile Haxe project with \x1b[38;5;214mHaxe\033[0m/\x1b[38;5;25mC++\033[0m (hxcpp)...", PROCESSING);
		SlushiUtils.printMsg('Creating [${hxmlFileName}.hxml]', PROCESSING);

		// make a temporal HXML
		try {
			var hxml:String = '
# File generated by HaxeNXCompiler v${Main.version}
	# Main parameters #########
	-cp ${jsonFile.haxeConfig.sourceDir}
	-main ${jsonFile.haxeConfig.hxMain}
	-D message.reporting=${reportStyle}
	# Default and required libraries #########
	-lib hxcpp
	-lib hx_libnx
	# HXCPP parameters #########
	-cpp ${jsonFile.haxeConfig.cppOutDir}
	-D HAXE_OUTPUT_PART=HAXE_NX_PROGRAM
	-D nx
	-D HX_NX
	-D static_link
	############################
	# Extra Haxe Libraries
	${finalHxLibs()}
	# Extra Haxe defines
	-D HAXENXCOMPILER_VERSION="${Main.version}"
	-D HAXENXCOMPILER_JSON_SWITCH_PROJECTNAME="${jsonFile.switchConfig.projectName}"
	${finalHxDefines()}
	# Extra options
	${finalOtherOptions()}
';
			// delete temporal HXML if already exists
			if (FileSystem.exists(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml')) {
				FileSystem.deleteFile(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml');
				SlushiUtils.printMsg('Deleted existing [${hxmlFileName}.hxml]', INFO);
			}
			File.saveContent(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml', hxml);
		} catch (e) {
			SlushiUtils.printMsg('Error creating [${hxmlFileName}.hxml]: ${e}', ERROR);
			exitCodeNum = 4;
			return;
		}

		var debugMode:Bool = forceDebugMode ? true : (jsonFile.haxeConfig.debugMode == true);

		SlushiUtils.printMsg('Created [${hxmlFileName}.hxml]', SUCCESS);

		if (debugMode) {
			SlushiUtils.printMsg("Haxe debug mode is enabled", INFO);
		}

		SlushiUtils.printMsg("Compiling \x1b[38;5;214mHaxe\033[0m project...\n------------------", PROCESSING);

		var startTime:Float = Sys.time();

		var compileProcess = null;

		if (debugMode) {
			compileProcess = Sys.command("haxe", ['${hxmlFileName}.hxml', '--debug']);
		} else {
			compileProcess = Sys.command("haxe", ['${hxmlFileName}.hxml']);
		}

		if (compileProcess != 0) {
			SlushiUtils.printMsg("\x1b[38;5;1m------------------\033[0m", NONE);
		} else {
			SlushiUtils.printMsg("\x1b[38;5;71m------------------\033[0m", NONE);
		}

		var endTime:Float = Sys.time();
		var elapsedTime:Float = endTime - startTime;
		var formattedTime:String = StringTools.trim(Math.fround(elapsedTime * 10) / 10 + "s");

		if (compileProcess != 0) {
			SlushiUtils.printMsg("\x1b[38;5;214mHaxe\033[0m compilation failed", ERROR);
			exitCodeNum = 2;
		}

		// delete temporal hxml and macros
		if (jsonFile.deleteTempFiles == true) {
			if (FileSystem.exists(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml')) {
				FileSystem.deleteFile(SlushiUtils.getPathFromCurrentTerminal() + '/${hxmlFileName}.hxml');
			}
		}

		if (exitCodeNum == 0) {
			SlushiUtils.printMsg('\x1b[38;5;214mHaxe\033[0m compilation successful, compilation time: ${formattedTime}\n', SUCCESS);
		}
	}

	public static function getExitCode():Int {
		return exitCodeNum;
	}

	static function finalHxLibs():String {
		var libs = "";

		for (lib in LibsManager.parseHXLibs()) {
			libs += lib + "\n\t";
		}

		return libs;
	}

	static function finalHxDefines():String {
		var defines = "";

		for (define in Defines.parseHXDefines()) {
			defines += define + "\n\t";
		}

		return defines;
	}

	static function finalOtherOptions():String {
		var options = "";

		for (option in Defines.parseOtherOptions()) {
			options += option + "\n\t";
		}

		return options;
	}
}
